# DATA TYPES

# Scalar types

**Bir skaler tip tek bir deÄŸeri temsil eder. Rust dÃ¶rt temel skaler tipe sahiptir:**

- integers
- floating-point numbers 
- Booleans
- characters

### Integer types

Rust, boyutlarÄ±na ve tamsayÄ± olup olmadÄ±klarÄ±na gÃ¶re farklÄ±lÄ±k gÃ¶steren Ã§eÅŸitli integer tÃ¼rleri sunar

- **signed** (iÅŸaretli) (**negatif** sayÄ±larÄ± temsil edebilir). Ä°ÅŸaretli tam sayÄ±lar, **hem negatif hem de pozitif** sayÄ±larÄ± temsil edebilirken,

- **unsigned** (iÅŸaretsiz) (yalnÄ±zca **negatif olmayan** sayÄ±larÄ± temsil eder).iÅŸaretsiz tam sayÄ±lar yalnÄ±zca **pozitif olan (sÄ±fÄ±r ve pozitif) sayÄ±larÄ± temsil eder.**


AÅŸaÄŸÄ±da, Rust'Ä±n tÃ¼m tamsayÄ± tÃ¼rlerinin bit cinsinden boyutlarÄ±, iÅŸaretli olup olmadÄ±klarÄ± ve deÄŸer aralÄ±klarÄ± ile birlikte listelendiÄŸi bir tablo bulunmaktadÄ±r:

| Length  | Signed | Unsigned |
|---------|--------|----------|
| 8-bit   | `i8`   | `u8`     |
| 16-bit  | `i16`  | `u16`    |
| 32-bit  | `i32`  | `u32`    |
| 64-bit  | `i64`  | `u64`    |
| 128-bit | `i128` | `u128`   |
| arch    | `isize`| `usize`  |


```
fn main() {
    // Signed integers
    let small_signed: i8 = -128; // Smallest value for i8
    let large_signed: i64 = 9_223_372_036_854_775_807; // Largest value for i64

    // Unsigned integers
    let small_unsigned: u8 = 0; // Smallest value for u8
    let large_unsigned: u128 = 340_282_366_920_938_463_463_374_607_431_768_211_455; // Largest value for u128

    println!("Small signed: {}", small_signed);
    println!("Large signed: {}", large_signed);
    println!("Small unsigned: {}", small_unsigned);
    println!("Large unsigned: {}", large_unsigned);
}
```

---

### Floating-point types

Float iÃ§in iki temel tÃ¼re sahiptir . **f32 ve f64**.

VarsayÄ±lan tÃ¼r **f64** 'tÃ¼r .

**Ã–RNEK :**

```
fn main() {
    let x = 2.0; // f64, double-precision
    let y: f32 = 3.0; // f32, single-precision

    // Arithmetic operations
    let sum = x + y as f64; // Type casting f32 to f64
    let difference = x - y as f64;
    let product = x * y as f64;
    let quotient = x / y as f64;

    println!("Sum: {}", sum);
    println!("Difference: {}", difference);
    println!("Product: {}", product);
    println!("Quotient: {}", quotient);
}
```

---

 ### Boolean type

```
fn main() {
    let t = true;
    let f: bool = false; // Explicit type annotation

    // Using Booleans in an if statement
    if t {
        println!("t is true");
    }

    if !f { // using ! to invert the Boolean value
        println!("f is false");
    }
}

```
---

### Character type

Rust'ta char tÃ¼rÃ¼ **4 bayt boyutundadÄ±r** ve tek bir Unicode Skaler DeÄŸerini temsil etmek iÃ§in kullanÄ±lÄ±r. 

```
fn main() {
    let c = 'z'; // ASCII character
    let z = 'ğ•'; // Unicode character (U+1D54F)
    let heart_eyed_cat = 'ğŸ˜»'; // Emoji

    // Iterating over characters in a string
    for char in "Hello, ä¸–ç•Œ!" ğŸš€.chars() {
        println!("{}", char);
    }
}

```

---
---
---

# Compound Types    

BileÅŸik tipler birden fazla deÄŸeri tek bir tipte gruplayabilir.

Rust'Ä±n iki  bileÅŸik tÃ¼rÃ¼ vardÄ±r: **tuples ve arrays.**

### Tuple type

Rust'ta tuple, **farklÄ± tÃ¼rlerdeki bir dizi deÄŸeri tek bir bileÅŸik tÃ¼rde bir araya getirmenin Ã§ok yÃ¶nlÃ¼ bir yoludur.** 

- Tuple'lar Ã¶zellikle bir fonksiyondan birden fazla deÄŸer dÃ¶ndÃ¼rmeniz gerektiÄŸinde veya bir struct'Ä± gerektirecek kadar iliÅŸkili olmayan bir grup deÄŸeri aktarmak istediÄŸinizde kullanÄ±ÅŸlÄ±dÄ±r.

- **Ã–zellikler**

**Fixed Length** (Sabit Uzunluk): Bir tuple'Ä±n boyutu bildirildikten sonra deÄŸiÅŸemez. Bu, oluÅŸturulduktan sonra bir tuple'a Ã¶ÄŸe ekleyemeyeceÄŸiniz veya tuple'dan Ã¶ÄŸe Ã§Ä±karamayacaÄŸÄ±nÄ±z anlamÄ±na gelir.

**Heterogeneous** (Heterojen): Tuple'lar farklÄ± tÃ¼rlerde Ã¶ÄŸeler iÃ§erebilir, bu da onlarÄ± belirli kullanÄ±m durumlarÄ± iÃ§in dizilerden daha esnek hale getirir.


```
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);

    // Destructuring a tuple into individual variables
    let (x, y, z) = tup;
    println!("The value of y is: {}", y);

    // Accessing tuple elements directly by their index
    let five_hundred = tup.0;
    let six_point_four = tup.1;
    let one = tup.2;

    println!("Values: {}, {}, {}", five_hundred, six_point_four, one);
}

```

---

### Array type

**Rust'ta dizi, sabit uzunlukta aynÄ± tÃ¼rden elemanlardan oluÅŸan bir koleksiyondur.**

**Rust'taki diziler varsayÄ±lan olarak deÄŸiÅŸmezdir ve bildirildikten sonra boyutlarÄ± deÄŸiÅŸtirilemez.** Bu, dizileri sabit boyutlu bir Ã¶ÄŸe koleksiyonuna ihtiyaÃ§ duyduÄŸunuz senaryolar iÃ§in uygun hale getirir.

**Ã–zellikler ve KullanÄ±m**

**Fixed Length** (Sabit Uzunluk): Bir dizinin boyutu derleme zamanÄ±nda belirlenir ve deÄŸiÅŸtirilemez. Bu, bellek kullanÄ±mÄ±nda Ã¶ngÃ¶rÃ¼lebilirlik ve verimlilik saÄŸlar.

**Stack Allocation** (YÄ±ÄŸÄ±n Tahsisi): Diziler heap yerine stack Ã¼zerinde tahsis edilir, bu da kÃ¼Ã§Ã¼k koleksiyonlar veya sabit boyutlu veri yapÄ±larÄ± iÃ§in daha verimli olabilir.

**Uniform Type** (Tek Tip TÃ¼r): Bir dizideki tÃ¼m elemanlar aynÄ± tipte olmalÄ±dÄ±r.

```
fn main() {
    let a = [1, 2, 3, 4, 5]; // Array of type [i32; 5]

    // Accessing elements
    let first = a[0]; // First element
    let second = a[1]; // Second element
    println!("First: {}, Second: {}", first, second);

    // Iterating over an array
    for element in a.iter() {
        println!("Value: {}", element);
    }
}

```


---
---
---

# Custom types

Rust, kendi veri tÃ¼rlerinizi tanÄ±mlamanÄ±za olanak tanÄ±r. 

**struct** ve **enum** anahtar sÃ¶zcÃ¼klerini kullanarak Ã¶zel veri tÃ¼rleri tanÄ±mlayabilirsiniz.


## Struct type :

Bir struct, anlamlÄ± bir grup oluÅŸturan birden fazla ilgili deÄŸeri adlandÄ±rmanÄ±za ve bir araya getirmenize olanak tanÄ±yan Ã¶zel bir veri tÃ¼rÃ¼dÃ¼r. 

Structlar tuple'lara benzer, ancak adlandÄ±rÄ±lmÄ±ÅŸ alanlarÄ± vardÄ±r. **YapÄ±lar, bir grup deÄŸere bir ad vermek ve kodunuzun amacÄ±nÄ± netleÅŸtirmek istediÄŸinizde kullanÄ±ÅŸlÄ±dÄ±r.**

```
struct Person {
  name: String,
  age: u8,
}

fn main() {
  // Creating an instance of the struct
  let person = Person {
  name: String::from("Alice"),
  age: 30,
};

  // Accessing fields of the struct
  println!("Name: {}", person.name);
  println!("Age: {}", person.age);
}

```

**Bu Ã¶rnekte:**

- Ä°ki alana sahip bir Person yapÄ±sÄ± tanÄ±mlarÄ±z: name (String tÃ¼rÃ¼nde) ve age (u8 tÃ¼rÃ¼nde).

- ArdÄ±ndan, alanlarÄ± belirli deÄŸerlerle baÅŸlatarak Person yapÄ±sÄ±nÄ±n bir Ã¶rneÄŸini oluÅŸturuyoruz.
makrosunu kullanarak

---

## Enum type

Rust'ta numaralandÄ±rmalarÄ±n kÄ±saltmasÄ± olan enum'lar, bir tÃ¼rÃ¼ olasÄ± varyantlarÄ±nÄ± numaralandÄ±rarak tanÄ±mlamanÄ±za olanak tanÄ±yan gÃ¼Ã§lÃ¼ Ã¶zel veri tÃ¼rleridir.

Her biri potansiyel olarak farklÄ± tÃ¼rde ve miktarda iliÅŸkili veriye sahip birkaÃ§ farklÄ± ÅŸeyden biri olabilen bir tÃ¼r oluÅŸturmak iÃ§in kullanÄ±ÅŸlÄ±dÄ±rlar.

**EnumlarÄ±n Temel Ã–zellikleri:**

**Varyantlar:** Enum'larÄ±n birden fazla varyantÄ± olabilir ve her varyant isteÄŸe baÄŸlÄ± olarak farklÄ± tÃ¼rde ve miktarda veri taÅŸÄ±yabilir.

**KalÄ±p EÅŸleÅŸtirme:** Enum'lar genellikle Rust'Ä±n match kontrol akÄ±ÅŸÄ± yapÄ±sÄ±yla birlikte kullanÄ±lÄ±r ve bu da enum'un varyantÄ±na baÄŸlÄ± olarak farklÄ± kod Ã§alÄ±ÅŸtÄ±rmanÄ±n bir yolunu saÄŸlar.

**YaygÄ±n KullanÄ±m DurumlarÄ±:** Enumlar hata iÅŸleme (Result enum), isteÄŸe baÄŸlÄ± deÄŸerler (Option enum) ve durum yÃ¶netimi iÃ§in yaygÄ±n olarak kullanÄ±lÄ±r.

```
// Define an enum to represent the states of a traffic light
enum TrafficLight {
    Red,
    Yellow,
    Green,
}

fn main() {
    let light = TrafficLight::Red;

    match light {
        TrafficLight::Red => println!("Stop"),
        TrafficLight::Yellow => println!("Caution"),
        TrafficLight::Green => println!("Go"),
    }
}

```

Bu Ã¶rnekte, TrafficLight Ã¼Ã§ Ã§eÅŸidi olan bir enum'dur: KÄ±rmÄ±zÄ±, SarÄ± ve YeÅŸil.

**TrafficLight::Red**'in bir Ã¶rneÄŸini oluÅŸturuyoruz ve ardÄ±ndan varyanta baÄŸlÄ± olarak farklÄ± eylemler gerÃ§ekleÅŸtirmek iÃ§in bir eÅŸleÅŸme deyimi kullanÄ±yoruz.


